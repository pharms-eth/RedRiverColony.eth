// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
error RRCServer_ServerNoPermission(
    uint256 serverId,
    address perp,
    string accessPoint
);
error RRCServer_InvalidStringParameter(string param, string value);
error RRCServer_InvalidUint256Parameter(string param, uint256 value);
error RRCServer_Index(uint256 index);
error RRCServer_InvalidAddressParameter(string parameter);
error RRCServer_UserAlreadyExists(uint256 serverId, address user);
error RRCServer_UserNotFound(uint256 serverId, address user);

// error InvalidServerId()
// error InvalidChannelId()
error RRCServer_ChannelAlreadyExists(uint256 channelId);
error RRCServer_ChannelNotFound(uint256 channelId);

contract RServer is ERC721 {
    struct Server {
        address owner;
        string name;
        uint256 id;
        uint256[] channels;
        address[] users;
        string icon;
        string message;
    }

    address public owner;
    uint256 private serverCount;
    mapping(uint256 => Server) private servers;
    string public constant TOKEN_URI =
        "ipfs://bafybeig37ioir76s7mg5oobetncojcm3c3hxasyd4rvid4jqhy4gkaheg4/?filename=0-PUG.json";

    event ServerNameChanged(uint256 indexed serverId, string newName);
    event ServerIconChanged(uint256 indexed serverId, string newIcon);
    event ServermessageChanged(uint256 indexed serverId, string newMessage);
    event UserDeletedFromServer(
        uint256 indexed serverId,
        address indexed userAddress
    );
    event ChannelDeletedFromServer(
        uint256 indexed serverId,
        uint256 indexed channelId
    );
    event ChannelAddedToServer(
        uint256 indexed serverId,
        uint256 indexed channelId
    );
    event UserAddedToServer(
        uint256 indexed serverId,
        address indexed userAddress
    );

    constructor(string memory _name) ERC721(_name, "RRCS") {
        owner = msg.sender;
    }

    function register(string memory _name) public returns (uint256) {
        serverCount = serverCount + 1;
        servers[serverCount] = Server(
            msg.sender,
            _name,
            serverCount,
            new uint256[](0),
            new address[](0),
            "",
            ""
        );
        _safeMint(msg.sender, serverCount);
        //set token URI
        //_setTokenURI()
        return serverCount;
    }

    function tokenURI(
        uint256 tokenId
    ) public view override returns (string memory) {
        // require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        return TOKEN_URI;
    }

    function withdraw() public {
        require(msg.sender == owner);
        (bool success, ) = owner.call{value: address(this).balance}("");
        require(success);
    }

    function getServerCount() public view returns (uint256) {
        return serverCount;
    }

    function getServer(uint256 serverId) public view returns (Server memory) {
        return servers[serverId];
    }

    function updateServerName(uint256 serverId, string memory newName) public {
        if (serverId <= 0 || serverId > serverCount) {
            revert RRCServer_Index(serverId);
        }

        if (servers[serverId].owner != msg.sender) {
            revert RRCServer_ServerNoPermission(
                serverId,
                msg.sender,
                "Update Name"
            );
        }

        if (bytes(newName).length <= 0 || bytes(newName).length > 256) {
            revert RRCServer_InvalidStringParameter("name", newName);
        }

        servers[serverId].name = newName;

        emit ServerNameChanged(serverId, newName);
    }

    function updateServerIcon(uint256 serverId, string memory newIcon) public {
        if (serverId <= 0 || serverId > serverCount) {
            revert RRCServer_Index(serverId);
        }

        if (servers[serverId].owner != msg.sender) {
            revert RRCServer_ServerNoPermission(
                serverId,
                msg.sender,
                "Update Icon"
            );
        }

        if (bytes(newIcon).length <= 0) {
            revert RRCServer_InvalidStringParameter("icon", newIcon);
        }

        servers[serverId].icon = newIcon;

        emit ServerIconChanged(serverId, newIcon);
    }

    function updateServerWelcomeMessage(
        uint256 serverId,
        string memory newMessage
    ) public {
        if (serverId <= 0 || serverId > serverCount) {
            revert RRCServer_Index(serverId);
        }

        if (servers[serverId].owner != msg.sender) {
            revert RRCServer_ServerNoPermission(
                serverId,
                msg.sender,
                "Update Welcome Message"
            );
        }

        if (bytes(newMessage).length <= 0) {
            revert RRCServer_InvalidStringParameter(
                "welcome message",
                newMessage
            );
        }

        servers[serverId].message = newMessage;

        emit ServermessageChanged(serverId, newMessage);
    }

    function addUserToServer(uint256 serverId, address userAddress) public {
        if (serverId <= 0 || serverId > serverCount) {
            revert RRCServer_Index(serverId);
        }

        if (servers[serverId].owner != msg.sender) {
            revert RRCServer_ServerNoPermission(
                serverId,
                msg.sender,
                "Add User"
            );
        }

        if (userAddress == address(0)) {
            revert RRCServer_InvalidAddressParameter("userAddress");
        }

        if (contains(servers[serverId].users, userAddress)) {
            revert RRCServer_UserAlreadyExists(serverId, userAddress);
        }

        servers[serverId].users.push(userAddress);

        emit UserAddedToServer(serverId, userAddress);
    }

    function deleteUserFromServer(
        uint256 serverId,
        address userAddress
    ) public {
        if (serverId <= 0 || serverId > serverCount) {
            revert RRCServer_Index(serverId);
        }

        if (servers[serverId].owner != msg.sender) {
            revert RRCServer_ServerNoPermission(
                serverId,
                msg.sender,
                "Delete User"
            );
        }

        Server storage server = servers[serverId];
        uint256 userIndex = getUserIndex(server, userAddress);
        if (userIndex >= server.users.length) {
            revert RRCServer_UserNotFound(serverId, userAddress);
        }

        // Swap the user to be deleted with the last user in the array
        if (userIndex < server.users.length - 1) {
            server.users[userIndex] = server.users[server.users.length - 1];
        }

        // Remove the last user from the array
        server.users.pop();

        // Emit an event to indicate that a user was deleted from the server
        emit UserDeletedFromServer(serverId, userAddress);
    }

    function getUserIndex(
        Server storage server,
        address userAddress
    ) internal view returns (uint256) {
        for (uint256 i = 0; i < server.users.length; i++) {
            if (server.users[i] == userAddress) {
                return i;
            }
        }
        return server.users.length;
    }

    function addChannelToServer(uint256 serverId, uint256 channelId) public {
        if (serverId == 0 || serverId > serverCount) {
            revert RRCServer_Index(serverId);
        }
        if (servers[serverId].owner != msg.sender) {
            revert RRCServer_ServerNoPermission(
                serverId,
                msg.sender,
                "add to channels"
            );
        }
        if (channelId == 0) {
            revert RRCServer_InvalidUint256Parameter("channel id", channelId);
        }
        if (contains(servers[serverId].channels, channelId)) {
            revert RRCServer_ChannelAlreadyExists(channelId);
        }

        servers[serverId].channels.push(channelId);

        emit ChannelAddedToServer(serverId, channelId);
    }

    function deleteChannelFromServer(
        uint256 serverId,
        uint256 channelId
    ) public {
        if (serverId == 0 || serverId > serverCount) {
            revert RRCServer_Index(serverId);
        }
        if (servers[serverId].owner != msg.sender) {
            revert RRCServer_ServerNoPermission(
                serverId,
                msg.sender,
                "delete channel"
            );
        }

        Server storage server = servers[serverId];
        uint256 channelIndex = getChannelIndex(server, channelId);
        if (channelIndex == server.channels.length) {
            revert RRCServer_ChannelNotFound(channelId);
        }

        // Swap the channel to be deleted with the last channel in the array
        if (channelIndex < server.channels.length - 1) {
            server.channels[channelIndex] = server.channels[
                server.channels.length - 1
            ];
        }

        // Remove the last channel from the array
        server.channels.pop();

        // Emit an event to indicate that a channel was deleted from the server
        emit ChannelDeletedFromServer(serverId, channelId);
    }

    function getChannelIndex(
        Server storage server,
        uint256 channelId
    ) internal view returns (uint256) {
        for (uint256 i = 0; i < server.channels.length; i++) {
            if (server.channels[i] == channelId) {
                return i;
            }
        }
        return server.channels.length;
    }

    function contains(
        address[] memory array,
        address element
    ) internal pure returns (bool) {
        for (uint256 i = 0; i < array.length; i++) {
            if (array[i] == element) {
                return true;
            }
        }
        return false;
    }

    function contains(
        uint256[] memory array,
        uint256 element
    ) internal pure returns (bool) {
        for (uint256 i = 0; i < array.length; i++) {
            if (array[i] == element) {
                return true;
            }
        }
        return false;
    }
}

// https://www.youtube.com/watch?v=gyMwXuJrbJQ
// Lesson 14: Hardhat NFTs
// (20:54:57) Random IPFS NFT
// (21:03:19) Random IPFS NFT part II - Mapping Chainlink VRF Requests
// (21:07:38) Random IPFS NFT part III - Creating Rare NFTs
// (21:15:19) Random IPFS NFT part IV - Setting the NFT images
// (21:19:02) Random IPFS NFT part  V - Setting an NFT Mint Price
// (21:24:25) Random IPFS NFT part  VI - Random IPFS NFT Recap
// (21:25:58) Random IPFS NFT part  VII - Deploy Script
// (21:31:08) Random IPFS NFT part  VIII  - Uploading token images with Pinata
// (21:47:27) Random IPFS NFT part  IX - Uploading token URIs (metadata) with Pinata
// (21:57:08) Random IPFS NFT part  X - Deploying III
// (22:00:52) Random IPFS NFT part  XI -  Random IPFS NFT Tests

// (22:03:11) Dynamic SVG On-Chain NFT
// (22:04:33) Dynamic SVG On-Chain NFT Part II - What is an SVG ?
// (22:07:06) Dynamic SVG On-Chain NFT Part III - Initial code
// (22:10:22) Dynamic SVG On-Chain NFT Part IV - Base64  Encoding
// (22:16:31) Advanced Section Encoding, Opcodes and Calls - abi.encode & abi.encodePacked
// (22:38:58) Advanced Section Encoding, Opcodes and Calls - abi.encode & abi.encodePacked - Introduction to Encoding Function Calls Directly
// (22:44:46) Advanced Section Encoding, Opcodes and Calls - abi.encode & abi.encodePacked - Encoding recap
// (22:46:46) Advanced Section Encoding, Opcodes and Calls - abi.encode & abi.encodePacked - Encoding Function Calls Directly
// (23:01:11) Dynamic SVG On-Chain NFT Part V - Creating an NFT TokenURI On-Chain
// (23:09:30) Dynamic SVG On-Chain NFT Part V - Making the NFT Dynamic
// (23:15:13) Dynamic SVG On-Chain NFT Part VI - Deploy Script
// (23:21:40) Dynamic SVG On-Chain NFT Part VII - Writing Tests
// (23:22:15) Deploying the NFT to a Testnet
// (23:34:11) Lesson 14 Recap

// (23:37:03) Lesson 15: NextJS NFT Marketplace (Full Stack / Front End)
// 	(23:43:23) Hardhat Setup
// 	(23:46:12) NftMarketplace.sol
// 	(24:06:26) Reentrancy Attacks
// 	(24:19:13) NftMarketplace.sol - Continued
// 	(24:26:17) NftMarketplace.sol - Deploy script
// 	(24:32:46) NftMarketplace.sol - Tests
// 	(24:43:38) NftMarketplace.sol - Scripts
// —————————————————————————————————
// (24:48:27) Part II: Moralis Front End - Introduction
// 	(24:52:33) NextJS Setup
// 	(25:01:59) Adding TailWind
// 	(25:05:31) Introduction to Indexing in Web3
// 	(25:12:09) What is Moralis
// 	(25:19:37) Connecting Moralis To our Local Hardhat Node
// 	(25:34:54) Moralis Event Sync
// 	(25:58:48) Resetting the Local Chain
// 	(26:00:56) Moralis Cloud Functions
// 	(26:19:42) Pratice Resetting The Local Chain
// 	(26:22:24) Moralis Cloud Functions II
// 	(26:42:12) Querying the Moralis Database
// 	(26:48:43) Rendering the NFT Images
// 	(27:17:16) Update Listing Modal
// 	(27:37:14) Buy NFT Listing
// 	(27:40:54) Sale Page Listing NFTs for Sale
// —————————————————————————————————
// (27:57:25) Part III: TheGraph Front End
// 	(28:03:07) What is The Graph ?
// 	(28:07:07) Building a Subgraph
// 	(28:35:19) Deploying our Subgraph
// 	(28:39:57) Reading from the Graph
// 	(28:51:39) Hosting our Dapp
// 	(28:53:10) Finished full stack basics
