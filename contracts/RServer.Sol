// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import {IERC721Metadata} from "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol";
import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";

error RRCServer_ServerNoPermission(
    uint256 serverId,
    address perp,
    string accessPoint
);
error RRCServer_InvalidStringParameter(string param, string value);
error RRCServer_InvalidUint256Parameter(string param, uint256 value);
error RRCServer_Index(uint256 index);
error RRCServer_InvalidAddressParameter(string parameter);
error RRCServer_UserAlreadyExists(uint256 serverId, address user);
error RRCServer_UserNotFound(uint256 serverId, address user);

// error InvalidServerId()
// error InvalidChannelId()
error RRCServer_ChannelAlreadyExists(uint256 channelId);
error RRCServer_ChannelNotFound(uint256 channelId);

//24843
contract RServer is ERC165, IERC721Metadata {
    enum UserRole {
        None,
        Member,
        Moderator,
        Admin
    }

    struct Server {
        address owner;
        string name;
        uint256 id;
        uint256[] channels;
        address[] users;
        string icon;
        string message;
        address nameResolver;
        // mapping(address => string) userRoles;
    }

    address public immutable contractOwner;
    string private _name;
    string private _symbol;
    uint256 private serverCount;
    mapping(uint256 => Server) private servers;
    mapping(uint256 => mapping(address => bool)) bannedUsers;
    mapping(uint256 => mapping(address => bool)) mutedUsers;
    mapping(uint256 => mapping(address => UserRole)) userRoles;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    event ServerNameChanged(uint256 indexed serverId, string newName);
    event ServerNameResolverChanged(uint256 indexed serverId, address newName);
    event ServerIconChanged(uint256 indexed serverId, string newIcon);
    event ServermessageChanged(uint256 indexed serverId, string newMessage);
    event UserDeletedFromServer(uint256 indexed serverId,address indexed userAddress);
    event MetadataUpdate(uint256 _tokenId);
    event ChannelDeletedFromServer(uint256 indexed serverId,uint256 indexed channelId);
    event ChannelAddedToServer(uint256 indexed serverId,uint256 indexed channelId);
    event UserAddedToServer(uint256 indexed serverId,address indexed userAddress);
    event UserMutedOnServer(uint256 indexed serverId,address indexed userAddress);
    event UserUnmutedOnServer(uint256 indexed serverId,address indexed userAddress);
    event UserBannedOnServer(uint256 indexed serverId,address indexed userAddress);
    event UserUnbannedOnServer(uint256 indexed serverId,address indexed userAddress);

    constructor(string memory name_) {
        _symbol = "RRCS";
        _name = name_;
        contractOwner = msg.sender;
    }


    // function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
    //     return
    //         interfaceId == type(IERC721).interfaceId ||
    //         interfaceId == type(IERC721Metadata).interfaceId ||
    //         interfaceId == type(IERC165).interfaceId;
    // }

    modifier onlyExistingToken(uint256 tokenId) {
        require(
            _exists(tokenId),
            "ERC721: operator query for nonexistent token"
        );
        _;
    }

    modifier onlyOwnerOf(uint256 tokenId, string memory _function) {
        address serverOwner = _ownerOf(tokenId);
        if (userRoles[tokenId][msg.sender] != UserRole.Admin || serverOwner != msg.sender) {
            revert RRCServer_ServerNoPermission(
                tokenId,
                msg.sender,
                _function
            );
        }
        _;
    }

    modifier tokenInRange(uint256 _serverId) {
        if (_serverId <= 0 || _serverId > serverCount) {
            revert RRCServer_Index(_serverId);
        }
        _;
    }

    modifier validateString(string memory _newValue, string memory _parameter) {
        if (bytes(_newValue).length <= 0) {
            revert RRCServer_InvalidStringParameter(_parameter, _newValue);
        }
        _;
    }

    modifier isAddressZero(address _address) {
        if (_address == address(0)) {
            revert RRCServer_InvalidAddressParameter("userAddress");
        }
        _;
    }

    function register(
        string memory name_,
        string memory _icon,
        address nameResolver
    ) public returns (uint256) {
        serverCount = serverCount + 1;
        servers[serverCount] = Server(
            msg.sender,
            name_,
            serverCount,
            new uint256[](0),
            new address[](0),
            _icon,
            "",
            nameResolver
        );

        unchecked {
            _balances[msg.sender] += 1;
        }

        emit Transfer(address(0), msg.sender, serverCount);
        return serverCount;
    }

    function burn(uint256 tokenId) public virtual onlyExistingToken(tokenId) onlyOwnerOf(tokenId, "BURN") {

        address serverOwner = _ownerOf(tokenId);
        
        unchecked {
            _balances[serverOwner] -= 1;
        }

        delete _tokenApprovals[tokenId];
        delete servers[tokenId];

        emit Transfer(serverOwner, address(0), tokenId);
    }

    function tokenURI(
        uint256 tokenId
    ) public view virtual onlyExistingToken(tokenId) returns (string memory) {

        string memory _tokenURI;// = servers[tokenId].uri;
        string memory base = _baseURI();

        // If there is no base URI, return the token URI.
        if (bytes(base).length == 0) {
            return _tokenURI;
        }
        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).
        if (bytes(_tokenURI).length > 0) {
            return string(abi.encodePacked(base, _tokenURI));
        }

        return "ipfs://bafybeig37ioir76s7mg5oobetncojcm3c3hxasyd4rvid4jqhy4gkaheg4/?filename=0-PUG.json";
        // return string(abi.encodePacked(base, tokenId.toString()))
        // {
        //     "title": "Asset Metadata",
        //     "type": "object",
        //     "properties": {
        //         "name": {
        //             "type": "string",
        //             "description": "Identifies the asset to which this NFT represents"
        //         },
        //         "description": {
        //             "type": "string",
        //             "description": "Describes the asset to which this NFT represents"
        //         },
        //         "image": {
        //             "type": "string",
        //             "description": "A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive."
        //         }
        //     }
        // }


    //         {
    //   "name": "My NFT",
    //   "description": "This is a description of my NFT.",
    //   "image": "https://example.com/my-nft.png",
    //   "ensName": "myNFT.eth",
    //   "attributes": [
    //     {
    //       "trait_type": "Rarity",
    //       "value": "Common"
    //     },
    //     {
    //       "trait_type": "Size",
    //       "value": "Large"
    //     }
    //   ],
    //   "external_url": "https://example.com/my-nft",
    //   "background_color": "ffffff"
    // }
    }

    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }

    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {
        return servers[tokenId].owner;
    }

    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return _ownerOf(tokenId) != address(0);
    }

    function ownerOf(uint256 tokenId) public view virtual returns (address) {
        address ownerOF = _ownerOf(tokenId);
        require(ownerOF != address(0), "ERC721: address zero is not a valid owner");
        return ownerOF;
    }

    function balanceOf(address owner) public view virtual isAddressZero(owner) returns (uint256) {
        return _balances[owner];
    }

    function withdraw() public {
        require(msg.sender == contractOwner);
        (bool success, ) = contractOwner.call{value: address(this).balance}("");
        require(success);
    }

    function banUser(uint256 _serverId, address _user) public tokenInRange(_serverId) onlyOwnerOf(_serverId, "Update Name") {
        bannedUsers[_serverId][_user] = true;
        emit UserBannedOnServer(_serverId, _user);
    }

    function unbanUser(uint256 _serverId, address _user) public tokenInRange(_serverId) onlyOwnerOf(_serverId, "Update Name") {
        bannedUsers[_serverId][_user] = false;
        emit UserUnbannedOnServer(_serverId, _user);
    }

    function isUserBanned(
        uint256 _serverId,
        address _user
    ) public view tokenInRange(_serverId) onlyOwnerOf(_serverId, "Update Name") returns (bool) {
        return bannedUsers[_serverId][_user];
    }

    function muteUser(uint256 _serverId, address _user) public tokenInRange(_serverId) onlyOwnerOf(_serverId, "Update Name") {
        mutedUsers[_serverId][_user] = true;
        emit UserMutedOnServer(_serverId, _user);
    }

    function unmuteUser(uint256 _serverId, address _user) public tokenInRange(_serverId) onlyOwnerOf(_serverId, "Update Name") {
        mutedUsers[_serverId][_user] = false;
        emit UserMutedOnServer(_serverId, _user);
    }

    function isUserMuted(
        uint256 _serverId,
        address _user
    ) public view tokenInRange(_serverId) onlyOwnerOf(_serverId, "Update Name") returns (bool) {
        return mutedUsers[_serverId][_user];
    }

    function setUserRole(uint256 _serverId, address _user, UserRole _role) public tokenInRange(_serverId) onlyOwnerOf(_serverId, "Permission Denied: User Role Modification") {
        userRoles[_serverId][_user] = _role;
    }

    function getUserRole(uint256 _serverId, address _user) public view tokenInRange(_serverId) returns (UserRole) {
        return userRoles[_serverId][_user];
    }

    function removeUserRole(uint256 _serverId, address _user) public tokenInRange(_serverId) onlyOwnerOf(_serverId, "Permission Denied: User Role Modification"){        
        userRoles[_serverId][_user] = UserRole.None;
    }

    function name() public view virtual returns (string memory) {
        return _name;
    }

    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    function getServerCount() public view returns (uint256) {
        return serverCount;
    }

    function getServer(uint256 serverId) public view onlyExistingToken(serverId) returns (Server memory) {
        return servers[serverId];
    }

    function updateServerName(uint256 serverId, string memory newName) public tokenInRange(serverId) onlyOwnerOf(serverId, "Update Name") validateString(newName, "name") {
        if (bytes(newName).length > 256) {
            revert RRCServer_InvalidStringParameter("name", newName);
        }

        servers[serverId].name = newName;

        emit ServerNameChanged(serverId, newName);
    }

    function updateServerIcon(uint256 serverId, string memory newIcon) public tokenInRange(serverId) onlyOwnerOf(serverId, "Update Icon") validateString(newIcon, "icon") {
        servers[serverId].icon = newIcon;
        emit ServerIconChanged(serverId, newIcon);
    }

    function updateServerWelcomeMessage(
        uint256 serverId,
        string memory newMessage
    ) public tokenInRange(serverId) onlyOwnerOf(serverId, "Update Welcom Message") validateString(newMessage,"welcome message" ) {
        servers[serverId].message = newMessage;

        emit ServermessageChanged(serverId, newMessage);
    }

    function updateServerNameResolver(uint256 serverId, address nameResolver) public tokenInRange(serverId) onlyOwnerOf(serverId, "Update Name") {
        servers[serverId].nameResolver = nameResolver;

        emit ServerNameResolverChanged(serverId, nameResolver);
    }

    function addUserToServer(uint256 serverId, address userAddress) public tokenInRange(serverId) onlyOwnerOf(serverId, "Add User") isAddressZero(userAddress) {
        if (contains(servers[serverId].users, userAddress)) {
            revert RRCServer_UserAlreadyExists(serverId, userAddress);
        }

        servers[serverId].users.push(userAddress);

        emit UserAddedToServer(serverId, userAddress);
    }

    function deleteUserFromServer(
        uint256 serverId,
        address userAddress
    ) public tokenInRange(serverId) onlyOwnerOf(serverId, "Delete User") isAddressZero(userAddress) {
        Server storage server = servers[serverId];
        uint256 userIndex = getUserIndex(server, userAddress);
        if (userIndex >= server.users.length) {
            revert RRCServer_UserNotFound(serverId, userAddress);
        }

        // Swap the user to be deleted with the last user in the array
        if (userIndex < server.users.length - 1) {
            server.users[userIndex] = server.users[server.users.length - 1];
        }

        // Remove the last user from the array
        server.users.pop();

        // Emit an event to indicate that a user was deleted from the server
        emit UserDeletedFromServer(serverId, userAddress);
    }

    function addChannelToServer(uint256 serverId, uint256 channelId) public tokenInRange(serverId) onlyOwnerOf(serverId, "Add to channels") {
        if (channelId == 0) {
            revert RRCServer_InvalidUint256Parameter("channel id", channelId);
        }
        if (contains(servers[serverId].channels, channelId)) {
            revert RRCServer_ChannelAlreadyExists(channelId);
        }

        servers[serverId].channels.push(channelId);

        emit ChannelAddedToServer(serverId, channelId);
    }

    function deleteChannelFromServer(
        uint256 serverId,
        uint256 channelId
    ) public tokenInRange(serverId) onlyOwnerOf(serverId, "delete channel") {
        Server storage server = servers[serverId];
        uint256 channelIndex = getChannelIndex(server, channelId);
        if (channelIndex == server.channels.length) {
            revert RRCServer_ChannelNotFound(channelId);
        }

        // Swap the channel to be deleted with the last channel in the array
        if (channelIndex < server.channels.length - 1) {
            server.channels[channelIndex] = server.channels[
                server.channels.length - 1
            ];
        }

        // Remove the last channel from the array
        server.channels.pop();

        // Emit an event to indicate that a channel was deleted from the server
        emit ChannelDeletedFromServer(serverId, channelId);
    }

    function getUserIndex(
        Server storage server,
        address userAddress
    ) internal view returns (uint256) {
        uint256 len = server.users.length;
        for (uint256 i = 0; i < len; i++) {
            if (server.users[i] == userAddress) {
                return i;
            }
        }
        return len;
    }

    function getChannelIndex(
        Server storage server,
        uint256 channelId
    ) internal view returns (uint256) {
        uint256 len = server.channels.length;
        for (uint256 i = len; i > 0; i--) {
            if (server.channels[i - 1] == channelId) {
                return i - 1;
            }
        }
        return len;
    }

    function contains(
        address[] memory array,
        address element
    ) internal pure returns (bool) {
        uint256 len = array.length;
        for (uint256 i = 0; i < len; i++) {
            if (array[i] == element) {
                return true;
            }
        }
        return false;
    }

    function contains(
        uint256[] memory array,
        uint256 element
    ) internal pure returns (bool) {
        uint256 len = array.length;
        for (uint256 i = 0; i < len; i++) {
            if (array[i] == element) {
                return true;
            }
        }
        return false;
    }

    function totalSupply() external view returns (uint256) {
        return serverCount;
    }

    function tokenByIndex(uint256 _index) external view tokenInRange(_index) returns (uint256) {
        return _index;
    }

    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {
        uint256 count;
        uint256 lastSeen;
        for (uint256 i = 0; i < serverCount; i++) {
            count += 1;
            if (servers[i].owner == _owner) {
                _index -= 1;
                lastSeen = count;
                if (_index == 0) {
                    return count;
                }
            }
        }

        return lastSeen;
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
        address owner = ownerOf(tokenId);
        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);
    }

    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public virtual {
        require(_isApprovedOrOwner(msg.sender, _tokenId), "ERC721: caller is not token owner or approved");
        _safeTransfer(_from, _to, _tokenId, data);
    }

	function safeTransferFrom(address _from, address _to, uint256 _tokenId) public virtual {
        safeTransferFrom(_from, _to, _tokenId, "");
    }

	function transferFrom(address from, address to, uint256 tokenId) public virtual {
        //solhint-disable-next-line max-line-length
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: caller is not token owner or approved");

        _transfer(from, to, tokenId);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory /*data*/) internal virtual {
        _transfer(from, to, tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal virtual {
        require(ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
        require(to != address(0), "ERC721: transfer to the zero address");

        // Clear approvals from the previous owner
        delete _tokenApprovals[tokenId];

        unchecked {
            _balances[from] -= 1;
            _balances[to] += 1;
        }
        servers[tokenId].owner = to;

        emit Transfer(from, to, tokenId);
    }

	function approve(address to, uint256 tokenId) public virtual {
        address owner = ownerOf(tokenId);
        require(to != owner, "ERC721: approval to current owner");

        require(
            msg.sender == owner || isApprovedForAll(owner, msg.sender),
            "ERC721: approve caller is not token owner or approved for all"
        );

        _approve(to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal virtual {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

	function getApproved(uint256 tokenId) public view virtual onlyExistingToken(tokenId) returns (address) {
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public virtual {
        _setApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {
        require(owner != operator, "ERC721: approve to caller");
        _operatorApprovals[owner][operator] = approved;
        emit ApprovalForAll(owner, operator, approved);
    }
}

// https://www.youtube.com/watch?v=gyMwXuJrbJQ
// Lesson 14: Hardhat NFTs
// (20:54:57) Random IPFS NFT
// (21:03:19) Random IPFS NFT part II - Mapping Chainlink VRF Requests
// (21:07:38) Random IPFS NFT part III - Creating Rare NFTs
// (21:15:19) Random IPFS NFT part IV - Setting the NFT images
// (21:19:02) Random IPFS NFT part  V - Setting an NFT Mint Price
// (21:24:25) Random IPFS NFT part  VI - Random IPFS NFT Recap
// (21:25:58) Random IPFS NFT part  VII - Deploy Script
// (21:31:08) Random IPFS NFT part  VIII  - Uploading token images with Pinata
// (21:47:27) Random IPFS NFT part  IX - Uploading token URIs (metadata) with Pinata
// (21:57:08) Random IPFS NFT part  X - Deploying III
// (22:00:52) Random IPFS NFT part  XI -  Random IPFS NFT Tests

// (22:03:11) Dynamic SVG On-Chain NFT
// (22:04:33) Dynamic SVG On-Chain NFT Part II - What is an SVG ?
// (22:07:06) Dynamic SVG On-Chain NFT Part III - Initial code
// (22:10:22) Dynamic SVG On-Chain NFT Part IV - Base64  Encoding
// (22:16:31) Advanced Section Encoding, Opcodes and Calls - abi.encode & abi.encodePacked
// (22:38:58) Advanced Section Encoding, Opcodes and Calls - abi.encode & abi.encodePacked - Introduction to Encoding Function Calls Directly
// (22:44:46) Advanced Section Encoding, Opcodes and Calls - abi.encode & abi.encodePacked - Encoding recap
// (22:46:46) Advanced Section Encoding, Opcodes and Calls - abi.encode & abi.encodePacked - Encoding Function Calls Directly
// (23:01:11) Dynamic SVG On-Chain NFT Part V - Creating an NFT TokenURI On-Chain
// (23:09:30) Dynamic SVG On-Chain NFT Part V - Making the NFT Dynamic
// (23:15:13) Dynamic SVG On-Chain NFT Part VI - Deploy Script
// (23:21:40) Dynamic SVG On-Chain NFT Part VII - Writing Tests
// (23:22:15) Deploying the NFT to a Testnet
// (23:34:11) Lesson 14 Recap

// (23:37:03) Lesson 15: NextJS NFT Marketplace (Full Stack / Front End)
// 	(23:43:23) Hardhat Setup
// 	(23:46:12) NftMarketplace.sol
// 	(24:06:26) Reentrancy Attacks
// 	(24:19:13) NftMarketplace.sol - Continued
// 	(24:26:17) NftMarketplace.sol - Deploy script
// 	(24:32:46) NftMarketplace.sol - Tests
// 	(24:43:38) NftMarketplace.sol - Scripts
// —————————————————————————————————
// (24:48:27) Part II: Moralis Front End - Introduction
// 	(24:52:33) NextJS Setup
// 	(25:01:59) Adding TailWind
// 	(25:05:31) Introduction to Indexing in Web3
// 	(25:12:09) What is Moralis
// 	(25:19:37) Connecting Moralis To our Local Hardhat Node
// 	(25:34:54) Moralis Event Sync
// 	(25:58:48) Resetting the Local Chain
// 	(26:00:56) Moralis Cloud Functions
// 	(26:19:42) Pratice Resetting The Local Chain
// 	(26:22:24) Moralis Cloud Functions II
// 	(26:42:12) Querying the Moralis Database
// 	(26:48:43) Rendering the NFT Images
// 	(27:17:16) Update Listing Modal
// 	(27:37:14) Buy NFT Listing
// 	(27:40:54) Sale Page Listing NFTs for Sale
// —————————————————————————————————
// (27:57:25) Part III: TheGraph Front End
// 	(28:03:07) What is The Graph ?
// 	(28:07:07) Building a Subgraph
// 	(28:35:19) Deploying our Subgraph
// 	(28:39:57) Reading from the Graph
// 	(28:51:39) Hosting our Dapp
// 	(28:53:10) Finished full stack basics